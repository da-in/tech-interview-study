# 시스템 콜(System Call)

## 시스템 콜이란?
**시스템 콜**은 운영체제의 커널이 제공하는 기능에 대해, 응용프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스다.  
즉, 커널 모드의 기능을 사용자 모드에서 사용할 수 있게 해준다.

</br>

## 시스텀 콜은 왜 필요한가?
보통 일반적으로 사용하는 프로그램은 **응용 프로그램**이다. 유저레벨의 프로그램은 유저레벨의 함수들 만으로는 많은 기능을 구현하기 힘들기에 **커널**의 도움을 반드시 받아야한다.</br>
이러한 작업은 **유저 모드**에서는 수행할 수 없고, **커널 모드**로 전환한 후에 수행할 수 있는 권한이 생긴다. </br>
커널 모드를 통한 이러한 작업은 반드시 **시스템 콜**을 통해 수행하도록 설계되어 있다.</br></br>

\* 유저모드? : PC 레지스터가 사용자 프로그램이 올라가 있는 메모리 위치를 가리키고 있을 때 현재 사용자 프로그램을 수행중이라고 하며, CPU가 유저모드에서 수행중이라고 한다. </br>
\* 커널모드? : PC 레지스터가 운영체제가 존재하는 부분을 가리키고 있다면 현재 운영체제의 코드를 수행중이라고 하며 CPU가 커널 모드에서 수행중이라고 한다.

<img width="600px" alt="UserMode to KernelMode" src="https://user-images.githubusercontent.com/102718303/213471690-d6f3ba1a-d434-42ff-b86b-c27671ee3a75.png">

> 권한이 필요한 이유? - 해커들이 악의적으로 시스템 콜을 사용하는 경우나 초보자가 아무렇게 함수를 호출해서 시스텀 전체를 망가지게 할 수도 있다.
> 그래서 커널 모드에서만 실행할 수 있게 설계되었고, 호출하면 운영체제에서 불법적인 접근이라 여겨 `trap`을 발생시킨다.

\* trap이 발생하면 `모드비트`를 0으로 전환한다.

</br>


## 어떤식으로 처리 되는가?
- 시스템 콜은 여러 종류의 기능으로 나누어진다.
- 각 시스템 콜에는 번호가 부여되고, 시스템 콜 인터페이스는 **시스템 콜 번호**와 **시스템 콜 핸들러 함수 주소**로 구성된 **시스템 콜 테이블**을 가진다.
- 운영체제는 자기 커널 영역에서 해당 인덱스가 가리키는 주소에 저장되어 있는 루틴을 수행한다.
- 작업이 완료되면 CPU에게 인터럽트를 발생시켜 수행이 완료 되었음을 알린다.

- **open()의 호출**
<img width="600" src="https://user-images.githubusercontent.com/102718303/213471830-984f5586-9b5c-40de-b3ee-17d6c09c6abb.png">

</br>

## 시스템 콜 예시
```
// in.txt에 있는 파일 내용과 같은 내용을 복사하여 out.txt 파일을 만드는 것
cp in.txt out.txt
```
리눅스 터미널에 위와 같은 명령어를 입력하면, 다음과 같은 시스템 콜이 발생한다.

1. 먼저 사용자로부터 입력을 받는데 이때 **I/O 시스템 콜**이 발생한다.
2. 이후 'cp' 프로그램을 실행하면 먼저 `in.txt` 파일이 현재 디렉토리에서 접근 가능한지를 확인하기 위한 시스템 콜이 발생한다.
    - 접근이 불가능하다면 에러를 발생시킨 후 프로그램이 종료된다. 이때도 시스템 콜이 발생한다.
3. 파일이 존재해 접근 가능하다면 복사한 파일을 저장하기 위해 `out.txt`파일명이 있는지 검사하기 위한 시스템 콜이 발생한다.

</br>

## 시스템 콜 함수의 유형

|범주|기능|Windows|Linux|
|--|--|--|--|
|프로세스 컨트롤|프로세스 실행|CreateProcess()|execlp(), execv()|
||프로세스 종료|ExitProcess()|exit(), kill()|
||프로세스 생성|CreateProcess()|fork(), clone()|
|파일 관리|파일 생성/삭제|CreateFile()|open()|
||파일 열기/닫기|CloseHandle()|close()|
||파일 읽기/쓰기|ReadFile()/WriteFile()|read()/write()|
|디바이스 관리|장치로 읽기/쓰기|ReadFile()/WriteFile()|read()/write()|
|정보 관리|현재 프로세스의 PID 반환||getpid()|
|||시간 지정|alarm()|
|||시간 대기|sleep()|
|통신|파이프 생성|CreatePipe()|pipe()|
|보안|퍼미션 설정|SetFileSecurity()|chmod()|

open(), read(), write(), fork(), exit()
CrateProcess(), WaitForSingleObject()

- 프로세스 컨트롤 `fork(), wait() 등`
  - 프로세스 생성 및 종료
  - 메모리에 로드, 실행
  - 메모리 할당
- 파일 관리 `open(), read(), write(), close() 등`
  - 파일 생성, 파일 삭제
  - 열기, 닫기
  - 읽기, 쓰기 
- 디바이스 관리 `read(), write() 등`
  - 디바이스 요청 및 해제
  - 읽기, 쓰기
  - 다바이스 속성 확인, 지정
- 정보 관리 `getpid(), alarm(), sleep() 등`
  - 시간 확인, 시간 지정
  - 시스템 데이터 확인, 지정
  - 프로세스, 파일, 디바이스 속성 가져오기/설정하기 
- 통신 `pipe(), mnap() 등`
  - 커뮤니케이션 연결 생성 및 삭제
  - 메세지 송신, 수신
  - 상태 정보 전달 
- 보안 `chmod(), umask() 등`
  - 퍼미션 획득/설정 

</br>

----
## Referance
- https://velog.io/@nnnyeong/OS-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C-System-Call
- https://fjvbn2003.tistory.com/306
- https://velog.io/@klloo/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C

