# TCP/IP 흐름제어 & 혼잡제어

## 개념
- 흐름제어 
  - **송신측**과 **수신측**의 데이터 처리 속도 차이를 해결하기 위한 기법
  - `Flow Cotrol`은 송신측이 패킷을 지나치게 많이 받지 않도록 조절하는 것
  - 수신측이 송신측에게 현재 자신의 상태를 피드백 해준다.
- 혼잡 제어
  - **송신측**의 데이터 전달과 **네트워크**의 데이터 처리 속도 차이를 해결하기 위한 기법

</br>

## 흐름제어
- 수신측이 송신측보다 데이터 처리 속도가 느린 경우 발생하는 문제이다.
- 수신측의 저장 용령을 초과한 이루에 도착하는 데이터들은 손실될 수 있고, 만약 손실 된다면 불필요한 응답과 데이터 전송이 발생한다.

</br>

## 흐름제어 해결방법

### **1. Stop and Wait** 

- 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법

</br>

### **2. Sliding Window**
- 수신측이 설정한 윈도우 크기만큼 송신측에서 확인응답 없이 세그먼트(패킷)를 전송하여 데이터의 흐름을 동적으로 조절하는 방법  
 
 </br>
 
### **동작 방식**
- 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 해당 패킷들의 전달이 확인되면 윈도우를 옆으로 옮김으로써 다음 패킷들을 전송
  
<img  width="600" src="https://user-images.githubusercontent.com/102718303/214805020-36be43ec-a5ae-4aa4-8485-393fe599d307.png">

\**Window : 받을 수 있는 최대 패킷의 수* </br>
\**TCP/IP를 사용하는 모든 호스트들은 송신, 수신을 위한 2개의 Window를 가지고 있다.* </br>
\**연결하는 과정에서 송신측이 수신측의 Receive Window size에 자신의 크기를 맞춘다.*</br>
  
  </br>
  
- 예시에서 최초로 수신자는 윈도우 사이즈를 7로 정한다.
- 송신자는 수신자의 확인 응답을 받기 전까지 데이터를 모두 전송한다.
- 수신자가 확인 응답을 보내면, 윈도우 사이즈를 충족할 수 있도록 옆으로 옮긴다.
- 데이터를 다 받을 때까지 과정 반복
 
### 재전송
- 송신측은 일정 시간 동안 수신측으로부터 확인 응답을 받지 못하면, 패킷을 재전송한다.
- 만약 재전송 했는데, 소실이 아니라 수신측의 버퍼 공간이 없는 경우라면 문제가 발생한다.
- 이를 위해 수신측은 확인 응답을 보내면서 남은 윈도우의 크기도 함께 보내준다.

</br>

## 혼잡 제어
- 데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 라우터가 처리하지 못한다.
- 송신측은 처리못한 데이터를 손실로 간주해 계속해서 재전송한다.
- 혼잡 제어는 송수신측 사이의 패킷 수를 제어하는 기능이고, 네크워크의 **오버플로우**를 방지한다.

</br>

## 해결 방법

### 1. AIMD (Additive Increse/Multicative Decrease)
- AIMD 방식은 처음에 패킷을 하나씩 보내고 문제없이 도착하면 윈도우의 크기를 1씩 증가시킨다.
- 만약 전송에 실패하면 윈도우 크기를 반으로 줄인다.
- 단점은 윈도우의 크기가 조금씩 늘어나기 때문에 정상 속도로 통신하기까지 시간이 오래걸린다.

<img width="600" src="https://user-images.githubusercontent.com/102718303/214809474-164fb47a-a188-4be9-92be-b0624724cbbb.png">

</br>

### 2. Slow Start (느린 시작)
- Slow Start는 AIMD의 단점을 보완하여 윈도우의 크기를 `1, 2, 4, 8,,,`로 증가시킨다.
- 만약 혼잡이 감지되면 윈도우의 크기를 1로 줄인다.

<img width="650" src="https://user-images.githubusercontent.com/102718303/214810091-61859509-af24-47a4-bf2c-44bfc97f5ffb.png">

</br>

### 3. 빠른 재전송
- 패킷을 받는 수신측은 세그먼트로 분할된 내용들이 순서대로 도착하지 않는 경우가 생길 수 있다.
- 따라서 수신측은 순서대로 잘 도착한 패킷의 다음 순번을 확인 응답과 함께 보낸다.
- 또한 이러한 확인 응답을 중복으로 3개를 받으면 재전송한다.
- 송신측은 자신이 설정한 \*타임 아웃시간과 무관하게 바로 패킷을 재전송 할 수 있기 때문에 재전송률을 빠르게 유지할 수 있다.

\**타임 아웃 : 여러 요인으로 인해 송신측의 데이터가 유실되거나, 확인 응답이 유실되어 시간 초과되는 경우*

</br>

### 4. 빠른 회복
- 른 회복은 혼잡 상태가 감지되면 윈도우 크기를 1로 줄이지 않고 반으로 줄인 뒤 1씩 증가시킨다.
- 증가는 **Slow Start 방식**으로 하지만 한번 혼잡을 겪으면 **AIMD 방식**으로 동작한다. 

</br>

----
## Referance
- https://steady-coding.tistory.com/507
- https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html
  
  
  
  
  
