## 동기/비동기 vs 블로킹/논블로킹
* **동기/비동기**
  * 행위에 대한 이야기이다.
  * 요청한 작업에 대해 완료 여부를 신경 써서 작업을 순차적으로 수행할지 아닌지에 대한 관점이다.
* **블로킹/논블로킹**
  * 함수 호출에서의 이야기이다. 기술적으로 명확히 구분된다.
  * 현재 작업이 차단 되는지 아닌지에 따라 다른 작업을 수행할 수 있는지에 대한 관점이다.

<br>

### 동기/비동기
* **동기(Synchronous)**
요청한 작업에 대해 완료 여부를 따져 순차대로 처리하는 것이다. 
A, B, C라는 3개의 작업이 있을 때, A->B->C 순서대로 실행하게 된다.
* **비동기(Asynchronous)**
요청한 작업에 대해 완료 여부를 따지지 않고 다른 작업들을 동시에 처리하는 것이다. I/O 작업과 같이 느린 작업이 발생할 때 기다리지 않고 다른 작업을 같이 처리하므로 동시에 처리하는 멀티 작업을 진행할 수 있다. 이는 전반적인 시스템 성능 향상에 도움을 줄 수 있다.
A, B, C라는 3개의 작업이 있을 때, A, B, C가 동시에 실행되고 있는 것이다.
![](https://velog.velcdn.com/images/kimgwon/post/f6281f19-fdb7-47db-875e-8ec187ad18a6/image.png)
![](https://velog.velcdn.com/images/kimgwon/post/172ea88a-e995-466f-8905-9ce911d400b2/image.png)

<br>

### 블로킹/논블로킹
* 블로킹
호출한 함수가 호출된 함수에게 제어권을 넘기는 것이다. 
A 함수가 B 함수를 호출한다면, A 함수는 B 함수를 호출하면서 제어권을 넘기고 A는 제어권이 없으므로 함수 실행을 멈춘다.
A라는 함수를 호출했을때, 기대하는 행위를 모두 끝마칠때까지 기다렸다가 리턴된다.
* 논블로킹
호출한 함수가 호출된 함수에게 제어권을 넘기지 않는 것이다.
A 함수가 B 함수를 호출한다면, A 함수는 B 함수를 호출만 하고 제어권은 넘기지 않는다. A는 제어권을 그대로 갖고 있으므로, 함수 실행를 계속 실행한다.
A라는 함수를 호출했을때, 기대하는 어떤 행위를 요청하고 바로 리턴된다.
> 제어권
함수의 코드나 프로세스의 실행 흐름을 제어할 수 있는 권리를 말한다.
![](https://velog.velcdn.com/images/kimgwon/post/a1b3c779-4359-4ccc-b133-720d4aba5d7d/image.png)


<br>

## 동기/비동기 + 블로킹/논블로킹 조합
**1. Sync Blocking (동기 + 블로킹)**
다른 작업이 진행되는 동안 자신의 작업을 처리하지 않고(Blocking), 다른 작업의 완료 여부를 바로 받아 순차적으로 처리(Sync)하는 방식이다. 다른 작업의 결과가 자신의 작업에 영향을 주는 경우에 활용할 수 있다.
![](https://velog.velcdn.com/images/kimgwon/post/d1dd177c-2a50-427a-a270-c614b4237146/image.png)

* ** 실생활 동작 예시**
카페에 카페 주인, 알바생1, 알바생2, 알바생3이 있다.
a. 주인: (알바생1에게 커피1을 부탁한다.)
b. 알바생1: 네. (커피 1 제작 중)
c. 주인: (알바생1이 작업을 다 할 때 까지 아무 일도 하지 않고 기다린다.)
d. 알바생1: (커피 1을 제작 완료) 커피1 제작 완료 했습니다.
e. 주인: (알바생2에게 커피2를 부탁한다.)
f. 알바생2: 네. (커피 2 제작 중)
g. 주인: (알바생2가 작업을 다 할 때 까지 아무 일도 하지 않고 기다린다.)
h. 알바생2: (커피 2를 제작 완료) 커피2 제작 완료 했습니다.
i. 주인: (알바생3에게 커피3을 부탁한다.)
...

* 코드 동작 예시
```js
const fs = require('fs'); // 파일 시스템 모듈 불러오기

// 동기적으로 파일 읽기
const data1 = fs.readFileSync('file1.txt', 'utf8'); // file1을 sync으로 read 함
console.log(data1); // 파일 내용 출력하고 적절한 처리를 진행

const data2 = fs.readFileSync('file2.txt', 'utf8'); 
console.log(data2); 

const data3 = fs.readFileSync('file3.txt', 'utf8'); 
console.log(data3);
```


**2. Sync Non-Blocking (동기 + 논블로킹)**
다른 작업이 진행되는 동안 자신의 작업을 처리하고(Non-Blocking), 다른 작업의 결과를 바로 처리하여 작업을 순차적으로 처리(Sync)하는 방식이다.
![](https://velog.velcdn.com/images/kimgwon/post/582a82d8-a9a0-4a39-b036-fadd7b18764d/image.png)

* ** 실생활 동작 예시**
카페에 카페 주인, 알바생1, 알바생2, 알바생3이 있다. 각 커피는 완료 후에 만들기 시작해야한다고 하자.
a. 주인: (알바생1에게 커피1을 부탁한다.)
b. 알바생1: 네. (커피 1 제작 중)
c. 주인: 커피1 다 만들었나요?
d. 알바생1: (커피 1 제작 중) 만드는 중 입니다.
e. 주인: 커피1 다 만들었나요?
f. 알바생1: (커피 1 제작 중) 만드는 중 입니다.
g. 알바생1: (커피 1을 제작 완료) 커피1 제작 완료 했습니다.
h. 주인: (알바생2에게 커피2를 부탁한다.)
i. 알바생2: 네. (커피 2 제작 중)
j. 주인: 커피2 다 만들었나요?
k. 알바생2: (커피 2 제작 중) 만드는 중 입니다.
l. 주인: 커피2 다 만들었나요?
...

* 코드 동작 예시
동기 + 논블로킹 코드를 표현하는데 적합한 대중적인 언어로 자바를 들 수 있다. 스레드 객체를 만들어 요청 작업을 백그라운드에 돌게 하고, 메인 메서드에서 while문을 통해 스레드가 모두 처리되었는지 끊임없이 확인하고, 처리가 완료되면 다음 메인 작업을 수행한다.
```java
// Runnable 인터페이스를 구현하는 클래스 정의
class MyTask implements Runnable {
    @Override
    public void run() {
        // 비동기로 실행할 작업
        System.out.println("Hello from a thread!");
    }
}

public class Main {
    public static void main(String[] args) {
        // Thread 객체 생성
        Thread thread = new Thread(new MyTask());

        // 스레드 실행
        thread.start();

        // Non-Blocking이므로 다른 작업 계속 가능
        System.out.println("Main thread is running...");

        // Sync를 위해 스레드의 작업 완료 여부 확인
        while (thread.isAlive()) {
            System.out.println("Waiting for the thread to finish...");
        }
        System.out.println("Thread finished!");
        
        System.out.println("Run the next tasks");
    }
}
```


3. Async Blocking (비동기 + 블로킹)
다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다리는(Blocking), 다른 작업의 결과를 바로 처리하지 않아 순서대로 작업을 수행하지 않는(Async) 방식이다. 실무에서 잘 마주하지 않아 다룰 일이 거의 없다.
Sync-blocking과 개념적으로 차이가 있지만, 성능적으로 차이가 없다. 보통 Asnyc-blocking은 개발자가 Async-NonBlocking으로 처리하려다가 실수하는 경우에 발생한다. 그래서 이 방식을 안티 패턴이라고 치부하기도 한다.
![](https://velog.velcdn.com/images/kimgwon/post/e398efd4-82b6-4ba8-9d58-0fb2e1538643/image.png)


4. Async Non-Blocking (비동기 + 논블로킹)
다른 작업이 진행되는 동안에도 자신의 작업을 처리하고(Non-Blocking), 다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는(Async) 방식이다. 다른 작업의 결과가 자신의 작업에 영향을 주지 않은 경우에 활용할 수 있다.
![](https://velog.velcdn.com/images/kimgwon/post/4963dd94-7983-499b-9f3a-ba6463721adf/image.png)

* **실생활 동작 예시**
카페에 카페 주인, 알바생1, 알바생2, 알바생3이 있다.
a. 주인: (알바생1에게 커피1을 부탁한다.)
b. 주인: (알바생2에게 커피2을 부탁한다.)
c. 주인: (알바생3에게 커피3을 부탁한다.)
d. 주인: (다른 작업을 한다.)
e. 알바생2: (커피 2를 제작 완료) 커피2 제작 완료 했습니다. -> 제작 시간에 따라 요청 순서와 완료 순서는 다르다.
f. 알바생1: (커피 1을 제작 완료) 커피1 제작 완료 했습니다.
g. 알바생3: (커피 3을 제작 완료) 커피3 제작 완료 했습니다.
...

* 코드 동작 예시
Sync Blocking에서 구현한 코드를 Asnyc Non-Blocking 방식으로 구현한 것이다. 차이점은 호출 함수에 콜백 함수를 넣음으로써 작업의 결과를 후처리 할 수 있다.
``` js
// 비동기적으로 파일 읽기
const fs = require('fs'); // 파일 시스템 모듈 불러오기

fs.readFile('file.txt', 'utf8', (err, data) => { // 파일 읽기 요청과 콜백 함수 전달
  if (err) throw err; // 에러 처리
  console.log(data); // 파일 내용 출력
});

fs.readFile('file2.txt', 'utf8', (err, data) => {
  if (err) throw err; 
  console.log(data);
});

fs.readFile('file3.txt', 'utf8', (err, data) => { 
  if (err) throw err; 
  console.log(data);
});

console.log('done'); // 작업 완료 메시지 출력
```

---
## 참고
https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC
https://hamait.tistory.com/m/930